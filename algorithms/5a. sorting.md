# Sorting

## Types of Sorts and Definitions

### 1. Selection Sort
Selection sort iterates through a list of elements, finding the smallest one, and putting it aside into a sorted list. While we iterate through unsorted and keep appending to sorted list.

https://medium.com/basecs/exponentially-easy-selection-sort-d7a34292b049

#### Psuedocode
1. Set smallest number/minimum to first element in array.
2. Look for smallest number/minimum element in list.
3. Swap value with item at index[min].
4. Increment index of [min] to next element.
5. Repeat until last element/list is sorted.

#### Implementation
```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # Find the minimum element in the remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

#### Time Complexity
- Time: O(n^2^)

### 2. Bubble Sort
Bubble sort iterates through the list/array that is given, and compares each pair of adjacent elements in list by size. If elements are in incorrect order, swap, and move onto next pair (large number bubbles to end of list first).

https://medium.com/basecs/bubbling-up-with-bubble-sorts-3df5ac88e592

#### Pseudocode
1. Set swapped to true
2. While swapped is true
    - Set swapped to false
    - Iterate through the list from index 0 to n-1
        - If the current element is greater than the next element
            - Swap the current element with the next element
            - Set swapped to true
3. Return the sorted list

#### Implementation
```python
def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr
```

#### Time Complexity
- Time: O(n^2^)

### 3. Insertion Sort
Insertion sort contains the logic of shifting around and inserting elements in order to sort an unordered list of any size.

https://medium.com/basecs/inching-towards-insertion-sort-9799274430da

#### Pseudocode
1. Initially, whole list is unsorted.
2. Mark the first element as sorted.
3. Look at next, unsorted element and compare to our sorted one.
4. Shift over any necessary elements to make space for the value being added.
5. Repeat steps 3-4 until completion.

#### Implementation
```python
def insertion_sort(arr):
    n = len(arr)
    
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr
```

#### Time Complexity
- Time: O(n^2^)

### Merge Sort
Merge sort breaks a collection in half. Then, it sorts the two halves and merges them together to form one completely sorted collection.

https://medium.com/basecs/making-sense-of-merge-sort-part-1-49649a143478

https://medium.com/basecs/making-sense-of-merge-sort-part-2-be8706453209

Divide and conquer:
1. Divide and break up problem into smallest possible subproblem of exact same type.
2. Conquer and tackle smallest subproblems first. Once we figure out a solution that works, use exact same technique to solve larger subproblems.
3. Combine answers and build up smaller subproblems until we end up applying same solution to larger, more complicated problem.

#### Implementation
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    return merge(left_half, right_half)

def merge(left, right):
    merged = []
    left_index = 0
    right_index = 0
    
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    
    while left_index < len(left):
        merged.append(left[left_index])
        left_index += 1
    
    while right_index < len(right):
        merged.append(right[right_index])
        right_index += 1
    
    return merged
```

Append operation:
1. Comparing items we want to combine together
2. Inserting them into our temporary array in sorted order

#### Time Complexity
- Time: O(n log n)

### Quick Sort
Quick sort chooses a pivot point, and partitions the collection around the pivot, so elements smaller than pivot are before it and elements larger than pivot are after it. Continues to choose pivot points and break down collection into single-element lists before combining them back to one collection.

https://medium.com/basecs/pivoting-to-understand-quicksort-part-1-75178dfb9313
https://medium.com/basecs/pivoting-to-understand-quicksort-part-2-30161aefe1d3

#### Pseudocode
1. Start with unsorted collection.
2. Choose an element as pivot (usually last element).
3. Create left reference, pointing to element at lowest index.
4. Create right reference, pointing to element at highest index (not pivot).
5. While left reference is less than pivot, move pointer one element to right. While right reference is greater than pivot, move pointer one element to left.
6. If both left reference is greater than pivot AND right reference is smaller than pivot, swap elements at two references.
7. Once index of left reference is greater than or equal to index of right reference, swap pivot with element at left reference.
8. Repeat 2-7 until everything is sorted.
9. Combine the lists together.

#### Time and Space Complexity
Dependent upon:
1. What we choose as partition
2. How sorted list already is
- `O(n log n)` for unsorted list and partition close to median.
- `O(n^2^)` for sorted(or nearly-sorted) list, or partition that is far from median.
- Don't use quicksort for mostly-sorted lists.
- Space: Technically requires `O(log n)` because of pointers needed during recursion, but algo requires minimal amount of space is still considered in-place.

#### Optimization
1. Parallelization
    a. Sort both partitions at same time
2. Median pivot
    a. Look at last few elements and select median from them to get an idea of entire collection.

#### When to Use
1. Don't care about maintaining order of our items (stability isn't important to us)
2. Need to use an algorithm that can fit all of our data to be sorted into memory, without using any external memory
3. Never have to deal with data that's sorted -- or mostly sorted

