# Sorting

## Types of Sorts and Definitions

### 1. Selection Sort
Selection sort iterates through a list of elements, finding the smallest one, and putting it aside into a sorted list. While we iterate through unsorted and keep appending to sorted list.

https://medium.com/basecs/exponentially-easy-selection-sort-d7a34292b049

#### Psuedocode
1. Set smallest number/minimum to first element in array.
2. Look for smallest number/minimum element in list.
3. Swap value with item at index[min].
4. Increment index of [min] to next element.
5. Repeat until last element/list is sorted.

#### Implementation
```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # Find the minimum element in the remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

#### Time Complexity
- Time: `O(n^2^)`

### 2. Bubble Sort
Bubble sort iterates through the list/array that is given, and compares each pair of adjacent elements in list by size. If elements are in incorrect order, swap, and move onto next pair (large number bubbles to end of list first).

https://medium.com/basecs/bubbling-up-with-bubble-sorts-3df5ac88e592

#### Pseudocode
1. Set swapped to true
2. While swapped is true
    - Set swapped to false
    - Iterate through the list from index 0 to n-1
        - If the current element is greater than the next element
            - Swap the current element with the next element
            - Set swapped to true
3. Return the sorted list

#### Implementation
```python
def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr
```

#### Time Complexity
- Time: `O(n^2^)`

### 3. Insertion Sort
Insertion sort contains the logic of shifting around and inserting elements in order to sort an unordered list of any size.

https://medium.com/basecs/inching-towards-insertion-sort-9799274430da

#### Pseudocode
1. Initially, whole list is unsorted.
2. Mark the first element as sorted.
3. Look at next, unsorted element and compare to our sorted one.
4. Shift over any necessary elements to make space for the value being added.
5. Repeat steps 3-4 until completion.

#### Implementation
```python
def insertion_sort(arr):
    n = len(arr)
    
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr
```

#### Time Complexity
- Time: `O(n^2^)`

### Merge Sort
Merge sort breaks a collection in half. Then, it sorts the two halves and merges them together to form one completely sorted collection.

https://medium.com/basecs/making-sense-of-merge-sort-part-1-49649a143478

Divide and conquer:
1. Divide and break up problem into smallest possible subproblem of exact same type.
2. Conquer and tackle smallest subproblems first. Once we figure out a solution that works, use exact same technique to solve larger subproblems.
3. Combine answers and build up smaller subproblems until we end up applying same solution to larger, more complicated problem.

#### Implementation
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    return merge(left_half, right_half)

def merge(left, right):
    merged = []
    left_index = 0
    right_index = 0
    
    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            merged.append(left[left_index])
            left_index += 1
        else:
            merged.append(right[right_index])
            right_index += 1
    
    while left_index < len(left):
        merged.append(left[left_index])
        left_index += 1
    
    while right_index < len(right):
        merged.append(right[right_index])
        right_index += 1
    
    return merged
```

Append operation:
1. Comparing items we want to combine together
2. Inserting them into our temporary array in sorted order

#### Time Complexity
- Time: `O(n log n)`